{"name":"Webit Script ","tagline":"A template-like script and engine, all writen with Java 5+.","body":"Webit Script -- to be awesome\r\n====\r\n\r\nA template-like script and engine, all writen with Java **(Java 5+)**.\r\n\r\nIt's grammar is very like Javascript, and with `<% %>` `${ }` like in JSP\r\n\r\n**Download: [Jar][jar]    [Javadoc][doc]    [Sources][sources]**\r\n\r\n**QQ 群(Group): 302505483**\r\n\r\n## How to use(如何使用)\r\n\r\n### Maven\r\n\r\n    <repositories>\r\n        <repository>\r\n            <id>webit-script</id>\r\n            <name>Webit script</name>\r\n            <url>http://zqq90.github.io/maven/</url>\r\n        </repository>\r\n    </repositories>\r\n    <dependencies>\r\n        ...\r\n        <dependency>\r\n            <groupId>com.github.zqq90.webit-script</groupId>\r\n            <artifactId>webit-script</artifactId>\r\n            <version>1.2.1</version>\r\n        </dependency>\r\n        ...\r\n    </dependencies>\r\n\r\n### Or Add jars\r\n\r\n + `webit-script-1.2.1.jar`\r\n\r\n### Code in Java like this\r\n\r\n    // !! engine 并不会被缓存, 请根据需要自行实现 Engine的单例模式\r\n    Engine engine = Engine.createEngine(\"/webit-script-config.props\", extraSettingsMap);\r\n    ...\r\n    // template 已缓存, 线程安全, 并自动检测模板源是否被更新\r\n    // 当然您也可以缓存 Template 实例，模板更新时更新实例内部AST, 其实例不会变化\r\n    Template template = engine.getTemplate(\"/your/template/path/filename.ext\");\r\n    ...\r\n    template.merge(parametersMap, outputStream); \r\n    //template.merge(parametersMap, writer);\r\n\r\n## Config(配置)\r\n\r\n+ 配置文件格式: Use Jodd-props, see:[Jodd Props doc][url_props_doc]\r\n  `Tips: Java-Properties also works`\r\n+ 多文件支持 \"/webit-script-config1.props,/webit-script-config2.props\"\r\n+ 可选额外参数: extraSettingsMap 类型为Map, 支持props 宏\r\n+ 默认配置: [webit-script-default.props] [default_config]\r\n\r\n## Grammar(语法)\r\n\r\n### Hello word\r\n\r\n    Hello Webit Script!\r\n    <%\r\n    var books;\r\n    {\r\n        for(book : books){\r\n    %>\r\n    ${for.iter.index}.《${book.name}》 ￥${book.price}\r\n    <%\r\n        }\r\n    }\r\n    {\r\n        //this is a function\r\n        var func = function(a, b){\r\n            return a + b + arguments[3];\r\n        };\r\n        echo func(\"a\", \"b\", \"c\");\r\n        echo '\\n';\r\n    }\r\n    {\r\n        var map = {\r\n            1: 1,\r\n            \"key2\": \"value2\",\r\n            3: 2 + 1\r\n        };\r\n        map[5] = 2 + 3;\r\n        for(key, value : map){\r\n            echo key + \":\" +value + \"\\n\";\r\n        }\r\n    }\r\n    %>\r\n\r\n更多实例可见:[测试模板][tests]\r\n\r\n### 结构\r\n\r\n+ 脚本必须都放在`<% %>` 内. `<% .code inside.. %> plain text outside`\r\n+ 替换占位符`${}` 只能允许带返回值的单个表达式,只能在脚本块`<% %>` 以外使用.`${ .. expression .. }` \r\n+ 转义字符 `\\\\` to `\\` , `\\<%` to `<%`, `\\${` to `${`\r\n+ Node: 只有紧挨 `<%` `${` 的 `\\` 才需要转义 , \r\n+ 转义窍门: 偶数个 `\\` 会 打印 一半数量的`\\` 并进入代码段, \r\n            奇数 会 打印 (count-1)/2 个 `\\` 然后打印被转移的符号。\r\n            \r\n\r\n### 注释\r\n\r\n+ 单行注释 `//` \r\n+ 块注释 `/* */` \r\n\r\n\r\n### 关键字\r\n\r\n    var  super  this\r\n    if  else\r\n    switch  case  default\r\n    for  do  while  break  continue \r\n    function  return\r\n    import  include  echo\r\n    native  new  @import\r\n\r\n### 保留的关键字\r\n\r\n    static  instanceof  class  const  final\r\n    throw  try  catch  finally\r\n\r\n### 操作符\r\n*与Java 保持一致，顺序按优先级从高到低*\r\n\r\n    [] . () @\r\n    =>\r\n    !  ~  ++  --  – (取负)\r\n    *  /  %\r\n    +  -\r\n    <<  >>  >>>\r\n    <  <=  >  >=\r\n    ^\r\n    |\r\n    &&\r\n    ||\r\n    ?:\r\n    ..\r\n    =  +=  -=  *=  /=  %=  ^=  <<=  >>=  >>>=\r\n\r\n### 语句\r\n+ 结尾分号不能省略\r\n\r\n### 作用域(代码段) `{ }`\r\n+ 作用域引用上层变量\r\n+ 本层作用域变量不会影响上层\r\n+ 同一作用域不能重复声明变量\r\n+ **模板传入的变量仅在该作用域查找同名变量并赋值**\r\n  *1. 调用模板传入的变量; 2.import 返回的变量*\r\n\r\n### 变量\r\n#### 变量声明 var\r\n\r\n    var a;\r\n    var a, b, c=0, d=\"d\";\r\n\r\n#### 变量名规则\r\n+ 先声明 后使用，所有变量 必须全部声明\r\n+ 可开启 弱声明模式，所有变量不需要 事先声明，解析时自动声明\r\n+ 对大小写敏感\r\n+ 不能使用关键字\r\n+ 仅能包含 0-9a-zA-Z_$\r\n+ 特殊变量名: \r\n++ `super.` 用于 取得指定上层且仅该层作用域的变量, 可嵌套`super.super.a`\r\n++ `this.` 用于 取得本层且仅本层作用域的变量, 可嵌套`this.super.a`\r\n++ `for.iter` 用于 最近一层for循环的 迭代状态对象, 可使用`super``this` 限定作用域`super.for.iter`\r\n\r\n### 数据结构\r\n#### 拥有动态类\r\n\r\n    var x                             //  null\r\n    var x2 = 6;                    //  数字\r\n    var x3 = \"Bill\";               //  字符串\r\n    var x4 = 'a';                   //  字符\r\n    var x5 = [1, \"string\"];     //  数组\r\n    var x6 = {};                    // Map\r\n\r\n#### 字符串\r\n+ 转义，`\\\\` `\\\"` `\\'` `\\n` `\\r` `\\t` `\\f` `\\b`\r\n+ 允许换行，行后转义字符 可屏蔽该换行符\r\n\r\n~~~~~\r\nvar string = \"第一行  \\\r\n这还是在第一行\r\n这是第二行\\n第三行\\n\r\n这是第五行，第四行是空行\";\r\n~~~~~\r\n\r\n### 数字\r\n\r\n    var x1=34;  //Integer\r\n    var x2=34L;  //Long\r\n    var x3=34.00; //Double\r\n    var x4=34.00D;  //Double\r\n    var x5=34.00F;  //Float\r\n    var x6 = 0b10101;  //二进制\r\n    var x7 = 0123; //八进制\r\n    var x8 = 0x1A; //十六进制\r\n\r\n### 布尔\r\n\r\n    var x = true;\r\n    var y = false;\r\n\r\n\r\n### 数组\r\n\r\n#### 带初始值的数组\r\n\r\n    var array = [1, \"a string\", book];\r\n    var item;\r\n    item = array[0];\r\n    item = array[1];\r\n    item = array[2];\r\n    array[0] = \"a new value\"；\r\n\r\n#### Native 方法声明定长数组,\r\n\r\n    // 引入生成数组的 native 方法\r\n    var new_int_array = native int [];\r\n    var new_Object_array = native Object [];\r\n    var new_DateTime_array = native java.util.DateTime [];\r\n    \r\n    //得到定长数组\r\n    var int_array = new_int_array(5); //长度为5 的int数组\r\n    var objects = new_Object_array(5);//长度为5 的Object数组\r\n    \r\n    var a;\r\n    a = objects[4];\r\n    objects[4]=4; // 自动 装箱为Integer 然后放入数组\r\n    var len = objects.length; //数组长度\r\n    len = objects.size; //数组长度\r\n    \r\n    //不定长数组 可使用Java提供的List实现\r\n    var new_list = native new java.util.ArrayList();\r\n    var list_add = native java.util.List.add(Object);\r\n    \r\n    var list = new_list();\r\n    list@list_add(0); \r\n    list@list_add(1);\r\n    \r\n    var a = list[0];\r\n    list[0] = \"zero\";\r\n    list[1] = \"a string\";\r\n\r\n### Map\r\n\r\n    var map = {};\r\n    var map2 = {1:1,\"2\",\"2\"};\r\n    map[\"key\"] = \"a string value\";\r\n    \r\n    var value = map[1];\r\n    value = map[\"2\"];\r\n    value = map[\"key\"];\r\n\r\n### Java对象\r\n#### 声明\r\n\r\n    var new_list = native new java.util.ArrayList();\r\n    var list = new_list();\r\n    var list2 = new_list();\r\n\r\n#### 访问属性\r\n\r\n    var book;\r\n    var name = book.name; // book.getName();\r\n    book.name = \"new name\"; //book.setName(\"new name\"); \r\n\r\n#### 访问方法\r\n*访问方法必须事先native导入成本地函数*\r\n\r\n    var list_add = native java.util.List.add(Object);\r\n    list@list_add(0);\r\n    list_add(list, 1);\r\n\r\n*访问静态方法*\r\n\r\n    var now = native java.lang.System.currentTimeMillis();\r\n    echo now();\r\n \r\n### 函数\r\n\r\n#### 声明\r\n+ 格式同java\r\n+ 可变参数, \r\n+ 可通过 arguments 获得所有传入的参数, java类型为 Object[]\r\n+ 可访问父层作用域\r\n+ 函数内部可嵌套函数\r\n\r\n\r\n~~~~~\r\nvar outSideVar;\r\nvar a;\r\nvar myFunc = function(arg1, arg2){\r\n    var arg3 = arguments[3]; // 如果没有将抛出异常,最好通过 arguments.size确认\r\n    outSideVar = \"a new \"; //可访问\r\n    var a = 0; //内部变量\r\n    super.a ++ ; //访问上层变量\r\n    var func = function(){ ... }; //内部嵌套函数\r\n}; //不要忘了分号！！！\r\n~~~~~\r\n\r\n\r\n#### 导入Java内的 方法\r\n+ 仅可导入公共类的公共方法, 包括静态方法 和 成员方法\r\n+ 可使用`@import` 导入类名 或者包名 用法同Java里的 `import`, 以简化类名输入\r\n+ ~~@import  java.util.*;~~ v1.2.0+ 不再支持导入包\r\n\r\n\r\n~~~~~\r\n@import  java.lang.System; //实际上默认已经导入  java.lang.* 只是演示使用方法\r\n@import  java.util.List;\r\n@import  java.util.ArrayList;\r\nvar now = native java.lang.System.currentTimeMillis();\r\nvar list_add = native List.add(Object);\r\nvar new_list = native new ArrayList(); // 导入 构造函数\r\nvar new_list2 = native new ArrayList(int); // 导入 构造函数\r\n~~~~~\r\n\r\n\r\n### 调用\r\n+ 可变参数个数, 多余函数同样会被传入, 多余函数是否被使用 取决于函数本身\r\n+ 缺少的参数 自动 null 填充, *为了良好的设计 不建议使用缺少函数自动填充*\r\n+ 可使用@ 将第一个参数 外置\r\n\r\n\r\n~~~~~\r\nfunc(arg1, arg2);\r\n//等同于\r\narg1@func(arg2);\r\nlist_add(list, item);\r\n//等同于\r\nlist@list_add(item);\r\n~~~~~\r\n\r\n\r\n### 重定向输出符 `=>`\r\n+ 作用: 将指定 范围 产生的输出流 重定向到 指定变量\r\n+ 意义: 可以延后输出\r\n+ **使用对象: 1. 代码段；  2. 函数调用**\r\n+ 数据格式: 使用OutputStream 时, 为 byte[] ; 使用 Writer 时, 为String.\r\n\r\n\r\n~~~~~\r\n    var out;\r\n    var book;\r\n    //代码段 输出重定向\r\n    {\r\n    echo \"a String\";\r\n    >${book.name} <\r\n    } => out; //不要忘了分号！！！\r\n    // \"a String\" 以及 book.name 都将输出到 out\r\n    \r\n    var out;\r\n    // 函数 输出重定向\r\n    func() => out;\r\n    //由于 `=>` 具有较高的优先级，也可以这么些\r\n    var a = arg1@func() => out +1; \r\n    //此时 a为 func()+1 , func() 本次执行的输出内容赋值给out\r\n~~~~~\r\n\r\n\r\n### import & include\r\n+ 区别: import  将把调用模板的 上层变量 推入调用层的当前已存在变量\r\n+ 共同点: 都会在调用位置产生 输出\r\n+ 将使用默认的Loader 加载模板，可使用相对路径或绝对路径\r\n+ 可跟随 一个 map 格式的传参\r\n+ 模板名可以动态生成\r\n+ import 可支持指定需要导出的变量, 否则只导出本层作用域内的同名变量\r\n\r\n\r\n~~~~~\r\n//相对路径\r\ninclude \"./book-head.wtl\";\r\n//等同于 \r\ninclude \"book-head.wtl\";\r\n//绝对路径\r\ninclude \"/copyright.wtl\";\r\n//动态模板名\r\nvar style = \"\";\r\nimport \"book-list-\"+ style  +\".wtl\";\r\n//可传入参数 函数同样也可以作为变量传输\r\nvar func = function(){}; \r\nvar book;\r\nimport \"book-head.wtl\"  {\"book\": book, \"func\":func};\r\n//传入Map 变量作为参数\r\nvar map =  {\"book\": book, \"func\":func}；\r\nmap[\"one\"] = 1; \r\nimport \"book-head.wtl\"  {map};\r\n//导出指定变量\r\nvar a;\r\nvar b;\r\n//导出 : a 到a ，c 到 b\r\nimport \"book-head.wtl\"  {\"param1\":1}  a,b=c;\r\n~~~~~\r\n\r\n### 关于条件判断的三种情况\r\n\r\n+ 如果是boolean(Boolean)值 会原封返回\r\n+ **如果 ==null 返回 false**\r\n+ **如果 是空集合 或者 空数组 (.size==0)  返回 false **\r\n+ 否则 返回 true\r\n\r\n\r\n### 三元条件运算符 & 其简写\r\n+ **操作符按 自右向左 结合 [不是执行顺序], 详解看下面例子**\r\n+ **简写时 `?:` 之间不能有空白**\r\n\r\n\r\n~~~~~\r\nvar a1 = isTrue ? \"Yes\" : \"No\";\r\n//简写\r\nvar a2 = value ?: defaultValue; //取默认值\r\n//自右向左 结合\r\nvar x =  expr1 ?  expr3 :  expr2 ? expr4 : expr5;\r\n//这个等同于\r\nvar x =  expr1 ?  expr3 :  (expr2 ? expr4 : expr5);\r\n// 如果 是 自左向右 就会变成这样\r\nvar x =  (expr1 ?  expr3 :  expr2) ? expr4 : expr5;\r\n//简写 就按 从左向右 “执行” \r\nvar a4 = list1 ?: list2 ?: list3;\r\n~~~~~\r\n\r\n### 判断语句\r\n#### 判断表达式 ?:\r\n#### 判断控制语句 if - else if - else\r\n+ 不能省略 `{  }`\r\n\r\n\r\n~~~~~\r\nif( ... ){\r\n    ...;\r\n}else if(...){\r\n    ...;\r\n}else{\r\n    ...;\r\n}\r\n~~~~~\r\n\r\n\r\n### 循环控制语句\r\n+ 支持 数组,  java.util.Collection, java.util.Iterator, java.util.Enumeration, CharSequence, java.util.Map, 整型递增/递减\r\n+ 当集合为null 或者为空时将不会执行循环\r\n+ 支持 else , 可选, 当不符合执行循环体的条件时执行else体.\r\n\r\n#### for-in\r\n\r\n    //集合 数组 等\r\n    for(item : list){\r\n        echo item;\r\n        //echo for.iter.index; // .isFirst .hasNext .isOdd .isEven\r\n    } else{\r\n        echo \"list is empty\";\r\n    }\r\n    //递增 \r\n    for(i: 3..6){\r\n        echo i;\r\n    }\r\n    //递减\r\n    for(i: 6..3){\r\n        echo i;\r\n        //支持 for.iter.*\r\n    }\r\n\r\n\r\n#### for-in Map version\r\n\r\n    for(key, value : map){\r\n        echo key + \" = \" value;\r\n        echo \"\\n\";\r\n        //同样支持 for.iter.*\r\n    }\r\n\r\n#### while do-while \r\n+ 不支持 for.iter 特殊变量\r\n\r\n\r\n~~~~~\r\n//\r\nvar iter;\r\n... ;\r\nwhile(iter.hasNext){\r\n    var item = iter.next;\r\n    ....;\r\n}\r\n//\r\ndo{\r\n    ....;\r\n}while( ... );\r\n~~~~~\r\n\r\n\r\n\r\n### Switch-Case\r\n\r\n+ 支持普通 Object, 包括 String \r\n+ 使用  Object.equls() 判断是否相等\r\n+ 需要 break, 否则无条件继续执行下一个标签的句柄\r\n+ 每个case 命名空间独立\r\n\r\n\r\n~~~~~\r\nswitch(a){\r\n    case 1:\r\n        ....;\r\n        break;\r\n    case \"c\": //String\r\n        ....;\r\n        break;\r\n    case 'c': //Char\r\n        ....;\r\n        break;\r\n    default:\r\n        ....;\r\n}\r\n~~~~~\r\n\r\n### break continue\r\n+ **支持 label, 直接操作该循环体 或 switch**\r\n\r\n\r\n~~~~~\r\n//break continue\r\noutter: for(i: 6..3){\r\n    echo i;\r\n    //支持 for.iter.*\r\n    inner: for(item : list){\r\n        if( ..... ){\r\n           break outter;\r\n        }\r\n        .....;\r\n        break; // break inner;\r\n    }\r\n    //\r\n    switch(a){\r\n        ...;\r\n        case 'x':\r\n           break outter;\r\n        ...;\r\n    }\r\n}\r\n~~~~~\r\n\r\n\r\n### 正在完善。。。\r\n\r\n### 其他\r\n\r\n\r\n\r\n## Performance(性能)\r\n\r\n+ 缺省开启ASM构建Native 调用减少反射, 不同于将整个模板编译成Java字节码,该方法不会造成无限制的perm溢出;\r\n+ 解析之后的Template AST会放入缓存, 检测到模板源文件改变时将重新加载资源并解析;\r\n+ 性能测试结果比较理想, 待比较权威的模版测试程序;\r\n+ 使用OutputStream 输出时, 选择 SimpleTextStatmentFactory 将会预先将纯文本根据缺省编码编码成字节流. \r\n+ boilit/ebm 测试结果 [![boilit/ebm](https://github.com/boilit/ebm)]  [![or see](http://boilit.github.io/bsl/zh/ability/jdk7utf8.html)]\r\n\r\n\r\n~~~~~\r\nEngine                                Time            Size\r\nBSL-2.0.0                              559        68118050\r\nwebit-script-1.1.4                     590        68318250\r\nHTTL-1.0.11                            958        68118050\r\nBeeTL-1.25.01                          958        68138070\r\nRythm-1.0.0-b10-SNAPSHOT              1624        48728680\r\nVelocity-1.7                          1834        75046912\r\nFreeMarker-2.3.19                     2369        68157440\r\nJdkStringBuffer-1.7.0_40               606        67395584\r\nJdkStringBuilder-1.7.0_40              735        67395584\r\n~~~~~\r\n\r\n\r\n## SPI\r\n\r\n+ TextStatmentFactory  对模板纯文本的存贮以及输出形式进行管理\r\n+ Filter   输出过滤\r\n+ CoderFactory   编码/解码\r\n+ Loader   模板资源加载(原ResourceLoader)\r\n+ Logger   日志\r\n+ GetResolver, SetResolver, OutResolver  Bean属性解释器\r\n+ NativeSecurityManager   Native调用安全管理器\r\n\r\n\r\n## Requirements(依赖)\r\n\r\n+ null\r\n\r\n## Contributing(贡献)\r\n\r\n+ Translation works\r\n+ code & doc: fork -> pull requests\r\n+ idea & bug report: [github-issue] [new_issue]\r\n+ donate:\r\n\r\n\r\n## License(许可证)\r\n \r\n**Webit Script** is released under the BSD License. See the bundled LICENSE file for\r\ndetails.\r\n**Webit Script** 依据 BSD许可证发布。详细请看捆绑的 [LICENSE][license] 文件。\r\n\r\n## Other License\r\n\r\n+ **Jodd**  under the BSD License. [License file][jodd_license]\r\n+ **ASM-3.3.1**  under the BSD License.[License file][asm_license]\r\n\r\n\r\n\r\n[jar]: http://zqq90.github.io/maven/com/github/zqq90/webit-script/webit-script/1.2.1/webit-script-1.2.1.jar\r\n[jar_joddin]: http://zqq90.github.io/maven/com/github/zqq90/webit-script/webit-script-joddinside/1.2.1/webit-script-joddinside-1.2.1.jar\r\n[sources]: http://zqq90.github.io/maven/com/github/zqq90/webit-script/webit-script/1.2.1/webit-script-1.2.1-sources.jar\r\n[doc]: http://zqq90.github.io/maven/com/github/zqq90/webit-script/webit-script/1.2.1/webit-script-1.2.1-javadoc.jar\r\n[url_props_doc]: http://jodd.org/doc/props.html\r\n[tests]: https://github.com/zqq90/webit-script/tree/master/webit-script/src/test/resources/webit/script/test/tmpls\r\n[default_config]: https://github.com/zqq90/webit-script/blob/master/webit-script/src/main/resources/webit-script-default.props\r\n[new_issue]: https://github.com/zqq90/webit-script/issues/new\r\n[license]: https://github.com/zqq90/webit-script/blob/master/LICENSE\r\n\r\n[jodd_down]: http://jodd.org/download/index.html\r\n[jodd_site]: http://jodd.org/index.html\r\n[jodd_doc]: http://jodd.org/doc/index.html\r\n[jodd_github]: https://github.com/oblac/jodd\r\n[jodd_license]: http://jodd.org/license.html\r\n[asm_license]: http://asm.ow2.org/license.html\r\n\r\n\r\n\r\n\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/zqq90/webit-script/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}